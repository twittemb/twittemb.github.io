<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Warp your mobile development"/><link rel="canonical" href="http://blog.warpfactor.io/posts/2021-12-10-EquatableError"/><meta name="twitter:url" content="http://blog.warpfactor.io/posts/2021-12-10-EquatableError"/><meta name="og:url" content="http://blog.warpfactor.io/posts/2021-12-10-EquatableError"/><title>Equatable Errors in Swift | Warp your mobile development</title><meta name="twitter:title" content="Equatable Errors in Swift | Warp your mobile development"/><meta name="og:title" content="Equatable Errors in Swift | Warp your mobile development"/><meta name="description" content="Error is a base type in Swift that aims to represent an issue happening in the application flow; thus, it is very common to use it as an existential type that will cross the application layers. With Error being a protocol, we can implement our own custom errors making them Equatable if needed. In doing so we might have to leak implementation details across the application. This article explores a way to make an error conform to Equatable without compromising its abstraction."/><meta name="twitter:description" content="Error is a base type in Swift that aims to represent an issue happening in the application flow; thus, it is very common to use it as an existential type that will cross the application layers. With Error being a protocol, we can implement our own custom errors making them Equatable if needed. In doing so we might have to leak implementation details across the application. This article explores a way to make an error conform to Equatable without compromising its abstraction."/><meta name="og:description" content="Error is a base type in Swift that aims to represent an issue happening in the application flow; thus, it is very common to use it as an existential type that will cross the application layers. With Error being a protocol, we can implement our own custom errors making them Equatable if needed. In doing so we might have to leak implementation details across the application. This article explores a way to make an error conform to Equatable without compromising its abstraction."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Warp your mobile development"/></head><head>                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109460106-1"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());

                  gtag('config', 'UA-109460106-1');
                </script></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üçè</span><span class="hidden md:block w-0 md:w-auto pl-1">Warp your mobile development</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/projects">PROJECTS</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/posts">MY POSTS</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">10 DECEMBER 2021<span class="text-gray-900 px-1">/</span><a href="/tags/language">LANGUAGE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Equatable Errors in Swift</h1></div><div class="container w-full max-w-6xl h-48 md:h-cover mx-auto bg-white bg-cover bg-center mt-8 sm:rounded" style="background-color: #465059; background-image:url('/Images/2021-12-10-EquatableError/header.jpg');"></div><div class="container max-w-5xl mx-auto md:-mt-32"><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>Equatable Error in Swift</h1><h1>Introduction</h1><p>Error is an easy to use protocol in Swift. As it can be used as an <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID275">existential type</a>, you can declare a value of type <code>Error</code> and pass it around:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">printError</span><span class="p">(</span><span class="kc">_</span> <span class="n">error</span><span class="p">:</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">NetworkError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{}</span>
<span class="kd">struct</span> <span class="nc">DatabaseError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{}</span>

<span class="kd">let</span> <span class="nv">error</span><span class="p">:</span> <span class="n">Error</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">()</span>
<span class="n">printError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="c1">// prints &quot;NetworkError()&quot;</span>
</div></code></pre><p>By using <code>Error</code> as an existential type, we avoid leaking implementation details. We can pass the <code>error</code> variable as the <code>Error</code> protocol to the <code>printError</code> function. The function does not need to know the underlying concrete <code>Error</code> type. The code becomes more decoupled and versatile since it can be used with any concrete error conforming to the protocol. This is basically what abstraction is all about.</p><p>Sometimes we need errors to be <code>Equatable</code>; unfortunately, <code>Equatable</code> cannot be used as an existential type. The following code won't compile:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">printError</span><span class="p">(</span><span class="kc">_</span> <span class="n">error</span><span class="p">:</span> <span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>In the same way, when we want to define an <code>Equatable</code> data type that embeds an <code>Error</code>, the <code>Equatable</code> conformance is broken due to the <code>Error</code> type:</p><pre><code><div class="highlight"><span></span><span class="kd">enum</span> <span class="nc">State</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="n">loaded</span>
    <span class="k">case</span> <span class="n">failed</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="c1">// Error does not conform to Equatable</span>
<span class="p">}</span>
</div></code></pre><p>We can try to enforce the conformance to <code>Equatable</code> for the embedded error, but for the aforementioned reason, this code won't compile either:</p><pre><code><div class="highlight"><span></span><span class="kd">enum</span> <span class="nc">State</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="n">loaded</span>
    <span class="k">case</span> <span class="n">failed</span><span class="p">(</span><span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>One way to make it work is to define our own <code>Equatable</code> error type:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">NetworkError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{}</span>
<span class="kd">struct</span> <span class="nc">DatabaseError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{}</span>

<span class="kd">enum</span> <span class="nc">StateError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">network</span><span class="p">(</span><span class="n">NetworkError</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">database</span><span class="p">(</span><span class="n">DatabaseError</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">State</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="n">loaded</span>
    <span class="k">case</span> <span class="n">failed</span><span class="p">(</span><span class="n">StateError</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>But this comes with a price: we leak the implementation details. We should not need to know the type of error, or even less, the technology behind it. Using <code>network</code> or <code>database</code> is an information reserved to the dependency injection layer, not the business layer. We want the error to be just that ... an <code>Error</code>.</p><p>One other way to overcome this problem would be to use constraint generics:</p><pre><code><div class="highlight"><span></span><span class="kd">enum</span> <span class="nc">State</span><span class="p">&lt;</span><span class="n">ErrorType</span><span class="p">:</span> <span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">&gt;:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="n">loaded</span>
    <span class="k">case</span> <span class="n">failed</span><span class="p">(</span><span class="n">ErrorType</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>This does not seem to be a good/easy solution:</p><ul><li>we still leak implementation details: <code>let state = State&lt;StateError&gt;.loading</code></li><li>we have to specify the error type even if the state is not <code>failed</code>: <code>let state: State = .loaded</code> won't compile because the <code>ErrorType</code> is missing.</li></ul><p>Before trying to find another solution to this problem, I think it is important to understand why the usage of <code>Equatable</code> can be tricky.</p><h2>The Equatable protocol</h2><p>According to the Swift Standard Library:</p><blockquote><p>Types that conform to the <code>Equatable</code> protocol can be compared for equality using the equal-to operator (<code>==</code>) or inequality using the not-equal-to operator (<code>!=</code>).</p></blockquote><p>A lot of Swift types conform to Equatable.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kd">let</span> <span class="nv">c</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">2</span>

<span class="n">a</span> <span class="p">==</span> <span class="n">b</span> <span class="c1">// false</span>
<span class="n">a</span> <span class="p">==</span> <span class="n">c</span> <span class="c1">// true</span>
</div></code></pre><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;2&quot;</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;3&quot;</span>
<span class="kd">let</span> <span class="nv">c</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;2&quot;</span>

<span class="n">a</span> <span class="p">==</span> <span class="n">b</span> <span class="c1">// false</span>
<span class="n">a</span> <span class="p">==</span> <span class="n">c</span> <span class="c1">// true</span>
</div></code></pre><p>Although <code>Int</code> and <code>String</code> both conform to <code>Equatable</code>, it does not mean they can be compared for equality.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;3&quot;</span>

<span class="n">a</span> <span class="p">==</span> <span class="n">b</span>

<span class="c1">// error: binary operator &#39;==&#39; cannot be applied to operands of type &#39;Int&#39; and &#39;String&#39;</span>
<span class="c1">// overloads for &#39;==&#39; exist with these partially matching parameter lists: (Int, Int), (String, String)</span>
</div></code></pre><p>The error seems logical: we cannot compare Ints and Strings for equality in the real life either. But what really forbids us from doing this in Swift? Well, the answer lies in the definition of the protocol:</p><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">protocol</span> <span class="nc">Equatable</span> <span class="p">{</span>
    <span class="c1">/// Returns a Boolean value indicating whether two values are equal.</span>
    <span class="c1">/// - Parameters:</span>
    <span class="c1">///   - lhs: A value to compare.</span>
    <span class="c1">///   - rhs: Another value to compare.</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==</span> <span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="kc">Self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="kc">Self</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>
<span class="p">}</span>
</div></code></pre><p>The <code>==</code> function expects two parameters of the same type, that is to say <code>Self</code>, the type conforming to <code>Equatable</code>. Obviously, <code>Int</code> and <code>String</code> are not of the same type. This explains why we can't compare them for equality.</p><p>Another carateristic of the <code>Equatable</code> protocol is that it cannot be used as an <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID275">existential type</a>.</p><p>If you try to use the <code>Equatable</code> protocol as an existential type:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">=</span> <span class="s">&quot;1&quot;</span>
</div></code></pre><p>You will be presented with this error:</p><blockquote><p>protocol 'Equatable' can only be used as a generic constraint because it has Self or associated type requirements</p></blockquote><p>In the protocol definition, <code>Self</code> is used to strictly identify the type to be compared so the test for equality can be performed. By hiding the concrete type of the variable for the benefit of <code>Equatable</code>, the compiler would use that signature for the equality check:</p><pre><code><div class="highlight"><span></span><span class="kd">static</span> <span class="kd">func</span> <span class="p">==</span> <span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="nb">Equatable</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="nb">Equatable</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{}</span>
</div></code></pre><p>There is not enough information in <code>Equatable</code> to perform such a comparison.</p><p>This is also what forbids us from using <code>Equatable</code> in arrays:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Equatable</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</div></code></pre><p>The compiler doesn't have enough information about each element. It would be impossible to perform a comparison for equality as a whole.</p><h2>EquatableError</h2><p>Let's get back to our problem:</p><ul><li>We want to use <code>Error</code> without leaking implementation details</li><li>We want to embed <code>Error</code> in some <code>Equatable</code> data type without breaking the <code>Equatable</code> conformance</li></ul><p>Ok, the base implementation could be:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">base</span><span class="p">:</span> <span class="n">Error</span>
<span class="p">}</span>
</div></code></pre><p>Obviously this won't compile since the <code>base</code> is not <code>Equatable</code> ... it's a snake biting its own tail!</p><p>Let's satisfy the compiler and add an <code>==</code> function:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">base</span><span class="p">:</span> <span class="n">Error</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">type</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="n">lhs</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="p">==</span> <span class="n">type</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="n">rhs</span><span class="p">.</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">localizedDescription</span> <span class="p">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">localizedDescription</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We make sure both <code>base</code> errors are the same type and their only property is equal, but it can be easily fooled:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">NetworkError</span><span class="p">:</span> <span class="n">LocalizedError</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">code</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">errorDescription</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">{</span> <span class="s">&quot;Foo&quot;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">errorA</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">errorB</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">errorA</span> <span class="p">==</span> <span class="n">errorB</span> <span class="c1">// will output `true`</span>
</div></code></pre><p>We would expect <code>errorA</code> and <code>errorB</code> to <strong>NOT BE</strong> equal because of their different <code>code</code> properties, but unfortunately only the <code>localizedDescription</code> is taken into account in the equality check.</p><p>We should depend on the <code>==</code> function of the <code>base</code> error:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">base</span><span class="p">:</span> <span class="n">Error</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">equals</span><span class="p">:</span> <span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>

    <span class="kd">init</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">base</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="p">=</span> <span class="n">base</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">equals</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span> <span class="k">as</span><span class="p">?</span> <span class="n">Base</span><span class="p">)</span> <span class="p">==</span> <span class="n">base</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">base</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Let's give it a spin:</p><pre><code><div class="highlight"><span></span><span class="kd">enum</span> <span class="nc">Reason</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">badNetwcork</span>
    <span class="k">case</span> <span class="n">noNetwork</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">NetworkError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">code</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">let</span> <span class="nv">reason</span><span class="p">:</span> <span class="n">Reason</span>
    <span class="kd">let</span> <span class="nv">isRecoverable</span><span class="p">:</span> <span class="nb">Bool</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">NetworkError</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">NetworkError</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">code</span> <span class="p">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">code</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">reason</span> <span class="p">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">reason</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">networkErrorA</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1701</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">badNetwcork</span><span class="p">,</span> <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">networkErrorB</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1701</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">badNetwcork</span><span class="p">,</span> <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">networkErrorC</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1702</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">noNetwork</span><span class="p">,</span> <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>

<span class="n">networkErrorA</span> <span class="p">==</span> <span class="n">networkErrorB</span> <span class="c1">// prints true üëç</span>
<span class="n">networkErrorA</span> <span class="p">==</span> <span class="n">networkErrorC</span> <span class="c1">// prints false üëç</span>

<span class="kd">let</span> <span class="nv">equatableErrorA</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">networkErrorA</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">equatableErrorB</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">networkErrorB</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">equatableErrorC</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">networkErrorC</span><span class="p">)</span>

<span class="n">equatableErrorA</span> <span class="p">==</span> <span class="n">equatableErrorB</span> <span class="c1">// prints true üëç</span>
<span class="n">equatableErrorA</span> <span class="p">==</span> <span class="n">equatableErrorC</span> <span class="c1">// prints false üëç</span>
</div></code></pre><p>The only downside of this implementation is the <code>Equatable</code> constraint on the <code>Base</code> type. What if we want to make any <code>Error</code> be an <code>EquatableError</code>?</p><p>Well, there's an acceptable solution to that:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">base</span><span class="p">:</span> <span class="n">Error</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">equals</span><span class="p">:</span> <span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>

    <span class="kd">init</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">base</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="p">=</span> <span class="n">base</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">equals</span> <span class="p">=</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="n">reflecting</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">==</span> <span class="nb">String</span><span class="p">(</span><span class="n">reflecting</span><span class="p">:</span> <span class="n">base</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">init</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">base</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="p">=</span> <span class="n">base</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">equals</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span> <span class="k">as</span><span class="p">?</span> <span class="n">Base</span><span class="p">)</span> <span class="p">==</span> <span class="n">base</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==</span> <span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">base</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>If the <code>base</code> error is not <code>Equatable</code> we can use reflection to inspect its internal structure and use it as a comparison point. Swift provides us with a handy <code>String</code> initializer for this:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">networkError</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1701</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">badNetwcork</span><span class="p">,</span> <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">description</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">reflecting</span><span class="p">:</span> <span class="n">networkError</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="c1">// will print NetworkError(code: 1701, reason: Reason.badNetwcork, isRecoverable: false)</span>
</div></code></pre><p>Using <code>String(reflecting:)</code> is an acceptable fallback, but not 100% reliable since we can still make the type conform to <code>CustomDebugStringConvertible</code> or <code>CustomStringConvertible</code> or <code>TextOutputStreamable</code> and influence the resulting String.</p><p>In the end our model can embed the <code>EquatableError</code> while being <code>Equatable</code> and without leaking implementation details.</p><pre><code><div class="highlight"><span></span><span class="kd">enum</span> <span class="nc">State</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="n">loaded</span>
    <span class="k">case</span> <span class="n">failed</span><span class="p">(</span><span class="n">EquatableError</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>Then we can still get the underlying concrete <code>Error</code>:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="k">case</span> <span class="kd">let</span> <span class="nv">State</span><span class="p">.</span><span class="n">failed</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">=</span> <span class="n">state</span><span class="p">,</span>
        <span class="kd">let</span> <span class="nv">networkError</span> <span class="p">=</span> <span class="n">error</span><span class="p">.</span><span class="n">base</span> <span class="k">as</span><span class="p">?</span> <span class="n">NetworkError</span> <span class="p">{</span>
    <span class="p">....</span>
<span class="p">}</span>
</div></code></pre><h2>Bonus</h2><p>We can add some nice utilities to our code.</p><p>First, let's make <code>EquatableError</code> conform to <code>CustomStringConvertible</code> and delegate the description to its base error.</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span><span class="p">,</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">&quot;</span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">base</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>In doing so, we can print the <code>EquatableError</code> as if it was its base.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">networkError</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="mi">1701</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">badNetwcork</span><span class="p">,</span> <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">equatableError</span> <span class="p">=</span> <span class="n">EquatableError</span><span class="p">(</span><span class="n">networkError</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">equatableError</span><span class="p">)</span> <span class="c1">// prints NetworkError(code: 1701, reason: Reason.badNetwcork, isRecoverable: false)</span>
</div></code></pre><p>In the same way, we can also delegate the <code>localizedDescription</code> to the base error:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span><span class="p">,</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kd">var</span> <span class="nv">localizedDescription</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">localizedDescription</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Let's also ease the making of an <code>EquatableError</code> from any error:</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">Error</span> <span class="k">where</span> <span class="kc">Self</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toEquatableError</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">EquatableError</span> <span class="p">{</span>
        <span class="n">EquatableError</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Error</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toEquatableError</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">EquatableError</span> <span class="p">{</span>
        <span class="n">EquatableError</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">equatableError</span> <span class="p">=</span> <span class="n">NetworkError</span><span class="p">(</span>
    <span class="n">code</span><span class="p">:</span> <span class="mi">1701</span><span class="p">,</span>
    <span class="n">reason</span><span class="p">:</span> <span class="p">.</span><span class="n">badNetwcork</span><span class="p">,</span>
    <span class="n">isRecoverable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">).</span><span class="n">toEquatableError</span><span class="p">()</span>
</div></code></pre><p>And finally, we can provide a helper function to unwrap the base error as a concrete <code>Error</code>:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span><span class="p">,</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kd">func</span> <span class="nf">asError</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span><span class="p">&gt;(</span><span class="n">type</span><span class="p">:</span> <span class="n">Base</span><span class="p">.</span><span class="kr">Type</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Base</span><span class="p">?</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="k">as</span><span class="p">?</span> <span class="n">Base</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">networkError</span> <span class="p">=</span> <span class="n">equatableError</span><span class="p">.</span><span class="n">asError</span><span class="p">(</span><span class="n">type</span><span class="p">:</span> <span class="n">NetworkError</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</div></code></pre><p>Here is the complete implementation for <code>EquatableError</code>:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">EquatableError</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nb">Equatable</span><span class="p">,</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">base</span><span class="p">:</span> <span class="n">Error</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">equals</span><span class="p">:</span> <span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>

    <span class="kd">init</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">base</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="p">=</span> <span class="n">base</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">equals</span> <span class="p">=</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="n">reflecting</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">==</span> <span class="nb">String</span><span class="p">(</span><span class="n">reflecting</span><span class="p">:</span> <span class="n">base</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">init</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span> <span class="o">&amp;</span> <span class="nb">Equatable</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">base</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="p">=</span> <span class="n">base</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">equals</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span> <span class="k">as</span><span class="p">?</span> <span class="n">Base</span><span class="p">)</span> <span class="p">==</span> <span class="n">base</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">EquatableError</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">base</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">&quot;</span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">base</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">asError</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">:</span> <span class="n">Error</span><span class="p">&gt;(</span><span class="n">type</span><span class="p">:</span> <span class="n">Base</span><span class="p">.</span><span class="kr">Type</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Base</span><span class="p">?</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span> <span class="k">as</span><span class="p">?</span> <span class="n">Base</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">localizedDescription</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">localizedDescription</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Error</span> <span class="k">where</span> <span class="kc">Self</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toEquatableError</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">EquatableError</span> <span class="p">{</span>
        <span class="n">EquatableError</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Error</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">toEquatableError</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">EquatableError</span> <span class="p">{</span>
        <span class="n">EquatableError</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>I hope this helps. Thanks for reading.</p><p>Special thanks to Ryan F. and Ryan G. for their reviews.</p></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="/Images/avatar.png" alt="Thibault Wittemberg"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Thibault Wittemberg</p><p class="text-gray-600 text-xs md:text-base">Mobile Solution Architect in Montreal üá®üá¶ (thibault.wittemberg@gmail.com)</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2019-07-20-Swift-AOP" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2019-07-20-Swift-AOP/puzzle.jpg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LANGUAGE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Swift: An Aspect Oriented Programming Language ?</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">To answer this question, we must first understand what is Aspect Oriented Programming (aka AOP). I like to see AOP as a response to a certain kind of failure of Object Oriented conceptions.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">13 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2017-11-01-EZStream" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2017-11-01-EZStream/ezstream-header.png" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">OPEN SOURCE, APPLICATION</p><div class="w-full font-bold text-2xl text-gray-900 px-6">EZStream</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">EZStream is the easiest way to stream your device camera in any web browser.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2017-11-08-RxFlow-Part1" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2017-11-08-RxFlow-Part1/RxFlow_Logo.png" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">OPEN SOURCE, REACTIVE PROGRAMMING</p><div class="w-full font-bold text-2xl text-gray-900 px-6">RxFlow Part 1: In Theory</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">This is a first article in a series that will be the heart of this blog for a while. I‚Äôm going to introduce RxFlow: a framework of my design implementing Reactive Flow Coordinator within iOS applications. RxFlow relies on RxSwift and is a project supported by the RxSwiftCommunity.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">5 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Warp your mobile development</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>