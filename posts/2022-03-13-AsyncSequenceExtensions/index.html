<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Warp your mobile development"/><link rel="canonical" href="http://blog.warpfactor.io/posts/2022-03-13-AsyncSequenceExtensions"/><meta name="twitter:url" content="http://blog.warpfactor.io/posts/2022-03-13-AsyncSequenceExtensions"/><meta name="og:url" content="http://blog.warpfactor.io/posts/2022-03-13-AsyncSequenceExtensions"/><title>AsyncSequence extensions | Warp your mobile development</title><meta name="twitter:title" content="AsyncSequence extensions | Warp your mobile development"/><meta name="og:title" content="AsyncSequence extensions | Warp your mobile development"/><meta name="description" content="Swift 5.5 introduced structured concurrency, and with it came AsyncSequence: a new way to provide a flow of values over time. Wait, what? Isn't this what Combine is all about? From Apple: "The Combine framework provides a declarative Swift API for processing values over time". Are these technologies similar? Interchangeable? Well, sort of! In this article we will explore the differences and similarities between them and we will go over a repo that brings Combine-like operators to AsyncSequence."/><meta name="twitter:description" content="Swift 5.5 introduced structured concurrency, and with it came AsyncSequence: a new way to provide a flow of values over time. Wait, what? Isn't this what Combine is all about? From Apple: "The Combine framework provides a declarative Swift API for processing values over time". Are these technologies similar? Interchangeable? Well, sort of! In this article we will explore the differences and similarities between them and we will go over a repo that brings Combine-like operators to AsyncSequence."/><meta name="og:description" content="Swift 5.5 introduced structured concurrency, and with it came AsyncSequence: a new way to provide a flow of values over time. Wait, what? Isn't this what Combine is all about? From Apple: "The Combine framework provides a declarative Swift API for processing values over time". Are these technologies similar? Interchangeable? Well, sort of! In this article we will explore the differences and similarities between them and we will go over a repo that brings Combine-like operators to AsyncSequence."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Warp your mobile development"/></head><head>                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109460106-1"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());

                  gtag('config', 'UA-109460106-1');
                </script></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üçé</span><span class="hidden md:block w-0 md:w-auto pl-1">Warp your mobile development</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/projects">PROJECTS</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/posts">MY POSTS</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">21 MARCH 2022<span class="text-gray-900 px-1">/</span><a href="/tags/open-source">OPEN SOURCE</a>, <a href="/tags/language">LANGUAGE</a>, <a href="/tags/reactive-programming">REACTIVE PROGRAMMING</a>, <a href="/tags/functional-programming">FUNCTIONAL PROGRAMMING</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">AsyncSequence extensions</h1></div><div class="container w-full max-w-6xl h-48 md:h-cover mx-auto bg-white bg-cover bg-center mt-8 sm:rounded" style="background-color: #465059; background-image:url('/Images/2022-03-13-AsyncSequenceExtensions/header.jpg');"></div><div class="container max-w-5xl mx-auto md:-mt-32"><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>It ain't no Combine, but ...</h1><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">seq1</span> <span class="p">=</span> <span class="n">AsyncSequence</span><span class="p">.</span><span class="n">From</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="kd">let</span> <span class="nv">seq2</span> <span class="p">=</span> <span class="n">AsyncSequence</span><span class="p">.</span><span class="n">From</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="kd">let</span> <span class="nv">currentValue</span> <span class="p">=</span> <span class="n">AsyncStreams</span><span class="p">.</span><span class="n">CurrentValue</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">try</span> <span class="k">await</span> <span class="n">AsyncSequences</span>
        <span class="p">.</span><span class="n">Merge</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span>
        <span class="p">.</span><span class="n">prepend</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">.</span><span class="n">handleEvents</span><span class="p">(</span><span class="n">onElement</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;new integer element </span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">})</span>
        <span class="p">.</span><span class="n">withLatestFrom</span><span class="p">(</span><span class="n">currentValue</span><span class="p">)</span>
        <span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">value</span> <span class="k">in</span> <span class="k">return</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">accumulator</span><span class="si">)</span><span class="s"> (</span><span class="si">\(</span><span class="n">value</span><span class="p">.</span><span class="mi">0</span><span class="si">)</span><span class="s"> </span><span class="si">\(</span><span class="n">value</span><span class="p">.</span><span class="mi">1</span><span class="si">)</span><span class="s">)&quot;</span> <span class="p">}</span>
        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;new element is collected </span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">currentValue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="n">currentValue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">termination</span><span class="p">:</span> <span class="p">.</span><span class="n">finished</span><span class="p">)</span>
</div></code></pre><p>At a first glance we could think it is 100% Combine code: <strong>Merge</strong>, <strong>prepend</strong>, <strong>handleEvents</strong>, <strong>scan</strong> and even <strong>CurrentValue</strong>. Those are things we are used to seeing in a reactive programming world.</p><p>However this is no Combine. This is 100% structured concurrency using <strong>AsyncSequence</strong> but with a little help from <a href="https://github.com/AsyncCommunity/AsyncExtensions">AsyncExtensions</a>. <strong>AsyncExtensions</strong> not only brings "Combine like" operators to AsyncSequence, it also provides helpers like <strong>Just</strong>, <strong>Timer</strong> or <strong>Zip</strong> and equivalents to <strong>Subject</strong> with <strong>Passthrough</strong>, <strong>CurrentValue</strong> or <strong>Replay</strong>.</p><p>Before exploring some operators that <strong>AsyncExtensions</strong> can offer, let's take a look at the fundamental nature of Combine and AsyncSequence with three simple diagrams.</p><h1>Different and similar at the same time</h1><h2>Combine</h2><p><strong>Combine</strong>, implementing a reactive programming paradigm, is a <strong>push</strong> and <strong>pull</strong> system. In other words, it implements both the <strong>Observer</strong> and <strong>Iterator</strong> patterns. To better understand this, let's take a look at this diagram:</p><img src="/Images/2022-03-13-AsyncSequenceExtensions/AsyncExtensions1.png" alt="Combine stream"/><p>There are three actors involved in a <strong>Combine</strong> stream:</p><ul><li>the Publisher: produces values over time</li><li>the Subscriber: demands an amount of values it can process</li><li>the Subscription: regulates the flow of values from the publisher to the subscriber</li></ul><p>Why do we need to regulate the flow of values? Because the subscriber might produce values faster than the subscriber can consume them. If we do not regulate the flow, then the subscriber might be overwhelmed by the amount of things to process and it could lead to an inconsistent state or even a crash. This mechanism is called <strong>back pressure management</strong>. It enforces that the publisher meets the demand of the subscriber, potentially using a queue to stack values.</p><p><strong>The important take away here, is that a Combine stream is a push and pull system.</strong></p><h2>AsyncSequence</h2><p>An <strong>AsyncSequence</strong> is simply an asynchronous version of the <strong>Sequence</strong> protocol. It is a <strong>pull</strong> system. In other word, it implements the <strong>Iterator</strong> pattern. To better understand this, let's take a look at this diagram:</p><img src="/Images/2022-03-13-AsyncSequenceExtensions/AsyncExtensions2.png" alt="AsyncSequence"/><p>There are two actors involved in an <strong>AsyncSequence</strong> usage:</p><ul><li>the AsyncSequence: produces on-demand values over time</li><li>the Client: demands values one by one</li></ul><p>Since this is not a <strong>push</strong> mechanism, the <strong>AsyncSequence</strong> cannot produce values unless it is explicitly asked to. There is no need for a regulation system. An <strong>AsyncSequence</strong>, by design, respects the pace of its client.</p><p><strong>The important take away here, is that an AsyncSequence is a pull-only system.</strong></p><h2>AsyncStream</h2><p>There is a special flavor to <strong>AsyncSequence</strong> that does not entirely respect the aforementioned definition. <strong>AsyncStream</strong> is a type of <strong>AsyncSequence</strong> that is also a <strong>push</strong> system.</p><p>To better understand this, let's take a look at this diagram:</p><img src="/Images/2022-03-13-AsyncSequenceExtensions/AsyncExtensions3.png" alt="AsyncSequence"/><p>There are three actors involved in an <strong>AsyncStream</strong> usage:</p><ul><li>the AsyncStream: produces values over time</li><li>the Client: demands values one by one</li><li>the Continuation: acts as a middleware between the <strong>AsyncStream</strong> and the <strong>Client</strong> stacking values and waiting for the <strong>Client</strong> to pull them</li></ul><p>For the same reason that a <strong>Combine</strong> stream needs a regulation system, so does an <strong>AsyncStream</strong>. Being a <strong>push</strong> and <strong>pull</strong> system, an <strong>AsyncStream</strong> needs an internal queue to stack values, waiting to be consumed by its client. The main difference with a <strong>Combine</strong> stream is that this is still a one by one <strong>pull</strong> system. The client sets the pace for values popping as if it was <strong>Combine</strong> stream with a constant demand of one.</p><p><strong>The important take away here, is that an AsyncStream is a push and pull system, with a client demand maxed out to one.</strong></p><h1>A trivial example of Combine operator porting: scan</h1><p><strong>scan</strong> is very similar to <strong>reduce</strong>, the only difference is that it will emit every intermediate value between the initial value and the last one. Although it is fairly simple, <code>scan</code> is not currently provided as an <strong>AsyncSequence</strong> operator.</p><p>Here is an example of its usage with <strong>Combine</strong>:</p><pre><code><div class="highlight"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="p">.</span><span class="n">publisher</span>
    <span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">currentValue</span> <span class="k">in</span>
        <span class="n">accumulator</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">currentValue</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    
<span class="c1">// will print:</span>
<span class="mi">1</span>
<span class="mi">12</span>
<span class="mi">123</span>
<span class="mi">1234</span>
<span class="mi">12345</span>
</div></code></pre><p>From that observation, we can infer the bevaviour we want for the equivalent <strong>AsyncSequence</strong>: each value served by its iterator should be the result of the execution of a closure taking the previous computed value and the next value from the source <strong>AsyncSequence</strong>.</p><p>Here is the <strong>AsyncIterator</strong> implementing such a behaviour:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">AsyncScanIterator</span><span class="p">&lt;</span><span class="n">SourceAsyncIterator</span><span class="p">:</span> <span class="n">AsyncIteratorProtocol</span><span class="p">,</span> <span class="n">Output</span><span class="p">&gt;:</span> <span class="n">AsyncIteratorProtocol</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">Element</span> <span class="p">=</span> <span class="n">Output</span>

    <span class="kd">var</span> <span class="nv">sourceIterator</span><span class="p">:</span> <span class="n">SourceAsyncIterator</span>
    <span class="kd">var</span> <span class="nv">currentValue</span><span class="p">:</span> <span class="n">Element</span>
    <span class="kd">let</span> <span class="nv">nextPartialResult</span><span class="p">:</span> <span class="p">(</span><span class="n">Element</span><span class="p">,</span> <span class="n">SourceAsyncIterator</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="k">async</span> <span class="p">-&gt;</span> <span class="n">Element</span>

    <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span>
        <span class="n">sourceIterator</span><span class="p">:</span> <span class="n">SourceAsyncIterator</span><span class="p">,</span>
        <span class="n">initialResult</span><span class="p">:</span> <span class="n">Element</span><span class="p">,</span>
        <span class="n">nextPartialResult</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">Element</span><span class="p">,</span> <span class="n">SourceAsyncIterator</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="k">async</span> <span class="p">-&gt;</span> <span class="n">Element</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">sourceIterator</span> <span class="p">=</span> <span class="n">sourceIterator</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">currentValue</span> <span class="p">=</span> <span class="n">initialResult</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">nextPartialResult</span> <span class="p">=</span> <span class="n">nextPartialResult</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="k">async</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">nextSourceValue</span> <span class="p">=</span> <span class="k">try</span> <span class="k">await</span> <span class="kc">self</span><span class="p">.</span><span class="n">sourceIterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">currentValue</span> <span class="p">=</span> <span class="k">await</span> <span class="kc">self</span><span class="p">.</span><span class="n">nextPartialResult</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">currentValue</span><span class="p">,</span> <span class="n">nextSourceValue</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">currentValue</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Here is an example of its usage with the corresponding <strong>AsyncSequence</strong>:</p><pre><code><div class="highlight"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="p">.</span><span class="n">asyncElements</span> <span class="c1">// computed property provided by AsyncExtensions that transforms a sequence in its async counterpart</span>
    <span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">currentValue</span> <span class="k">in</span>
        <span class="n">accumulator</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">currentValue</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>
    <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// a function provided by AsyncExtensions that iterates over an async sequence in a functional style</span>
    
<span class="c1">// will print:</span>
<span class="mi">1</span>
<span class="mi">12</span>
<span class="mi">123</span>
<span class="mi">1234</span>
<span class="mi">12345</span>
</div></code></pre><p>There is no particular difficulty in implementing such an operator. A <strong>pull</strong> system is well suited for that kind of linear output, one value at a time, at the client's pace.</p><h1>Not that trivial when chronology matters: Timer</h1><p>Let's try to re-implement an <strong>AsyncSequence</strong> version of <strong>Combine</strong> <code>Timer.publish(every:on:in:)</code>. I can see two ways of doing so: one involves a traditional <strong>AsyncSequence</strong>, the other involves an <strong>AsyncStream</strong>.</p><p>For the sake of this demonstration, we will limit the Timer to a 1 second interval.</p><h2>AsyncSequence</h2><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">AsyncTimerSequence</span><span class="p">:</span> <span class="n">AsyncSequence</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">AsyncIterator</span> <span class="p">=</span> <span class="n">Iterator</span>
    <span class="kd">typealias</span> <span class="n">Element</span> <span class="p">=</span> <span class="n">Date</span>

    <span class="kd">func</span> <span class="nf">makeAsyncIterator</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">AsyncIterator</span> <span class="p">{</span>
        <span class="n">Iterator</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="nc">Iterator</span><span class="p">:</span> <span class="n">AsyncIteratorProtocol</span> <span class="p">{</span>
        <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="k">async</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span>
            <span class="k">guard</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
            <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">1_000_000_000</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Date</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h2>AsyncStream</h2><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">AsyncTimerStream</span><span class="p">:</span> <span class="n">AsyncSequence</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">AsyncIterator</span> <span class="p">=</span> <span class="n">Iterator</span>
    <span class="kd">typealias</span> <span class="n">Element</span> <span class="p">=</span> <span class="n">Date</span>

    <span class="kd">func</span> <span class="nf">makeAsyncIterator</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">AsyncIterator</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">timerStream</span> <span class="p">=</span> <span class="n">AsyncStream</span><span class="p">&lt;</span><span class="n">Date</span><span class="p">&gt;(</span><span class="n">Date</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">bufferingPolicy</span><span class="p">:</span> <span class="p">.</span><span class="n">unbounded</span><span class="p">,</span> <span class="p">{</span> <span class="n">continuation</span> <span class="k">in</span>
            <span class="n">Task</span> <span class="p">{</span>
                <span class="k">while</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="p">{</span>
                    <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">1_000_000_000</span><span class="p">)</span>
                    <span class="n">continuation</span><span class="p">.</span><span class="n">yield</span><span class="p">(</span><span class="n">Date</span><span class="p">())</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">continuation</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="k">return</span> <span class="n">timerStream</span><span class="p">.</span><span class="n">makeAsyncIterator</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h2>Let's see how it behaves</h2><p>With <strong>AsyncTimerSequence</strong>:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">asyncTimerSequence</span> <span class="p">=</span> <span class="n">AsyncTimerSequence</span><span class="p">()</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerSequence</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// 2022-03-15 20:00:24 +0000</span>
<span class="c1">// 2022-03-15 20:00:25 +0000</span>
<span class="c1">// 2022-03-15 20:00:26 +0000</span>
</div></code></pre><p>With <strong>AsyncTimerStream</strong>:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">asyncTimerStream</span> <span class="p">=</span> <span class="n">AsyncTimerStream</span><span class="p">()</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerStream</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// 2022-03-15 20:00:24 +0000</span>
<span class="c1">// 2022-03-15 20:00:25 +0000</span>
<span class="c1">// 2022-03-15 20:00:26 +0000</span>
</div></code></pre><p>So far both implementations behave the same, printing dates with a 1s interval. As we saw, an <strong>AsyncSequence</strong> is a <strong>pull</strong> system only: the client imposes its pace. What happens if the client performs a long operation between each iteration?</p><p>Let's simulate that with a <code>Task.sleep(nanoseconds: 2_000_000_000)</code>.</p><p>With <strong>AsyncTimerSequence</strong>:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">asyncTimerSequence</span> <span class="p">=</span> <span class="n">AsyncTimerSequence</span><span class="p">()</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerSequence</span> <span class="p">{</span>
    <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">2_000_000_000</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// 2022-03-15 20:04:24 +0000</span>
<span class="c1">// 2022-03-15 20:04:27 +0000</span>
<span class="c1">// 2022-03-15 20:04:30 +0000</span>
</div></code></pre><p>Dates are printed every 3s, and their values have indeed a 3s interval (1s for the Timer + 2s for each iteration).</p><p>With <strong>AsyncTimerStream</strong>:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">asyncTimerStream</span> <span class="p">=</span> <span class="n">AsyncTimerStream</span><span class="p">()</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerStream</span> <span class="p">{</span>
    <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">2_000_000_000</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// 2022-03-15 20:04:24 +0000</span>
<span class="c1">// 2022-03-15 20:04:25 +0000</span>
<span class="c1">// 2022-03-15 20:04:26 +0000</span>
</div></code></pre><p>Dates are printed every 2s <strong>BUT</strong> their values have a 1s interval.</p><p>This is because <strong>AsyncStream</strong> is a both a <strong>push</strong> and <strong>pull</strong> system. Each date is pushed every 1s in the continuation, independently from their consumption (which happens every 2s).</p><p>I'm not saying there is a best way to implement a Timer, but it is important to be aware of the different strategies. Of course we can mitigate this by decoupling the dates consumption from their creation by wrapping the long operation inside a <strong>Task</strong>.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerSequence</span> <span class="p">{</span>
    <span class="n">Task</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">2_000_000_000</span><span class="p">)</span>
        <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// or</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">element</span> <span class="k">in</span> <span class="n">asyncTimerStream</span> <span class="p">{</span>
    <span class="n">Task</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">2_000_000_000</span><span class="p">)</span>
        <span class="bp">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>With that in place both Timers behave the same.</p><h1>What about concurrent clients?</h1><p>Concurrent clients mean iterating over the same <strong>AsyncSequence</strong> from several concurrent loops. We can give it a try with a trivial example: an <strong>AsyncSequence</strong> that provides every 1s an auto-incremented <strong>counter</strong> to clients.</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">AsyncCounterSequence</span><span class="p">:</span> <span class="n">AsyncSequence</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">AsyncIterator</span> <span class="p">=</span> <span class="n">Iterator</span>
    <span class="kd">typealias</span> <span class="n">Element</span> <span class="p">=</span> <span class="nb">Int</span>

    <span class="kd">func</span> <span class="nf">makeAsyncIterator</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">AsyncIterator</span> <span class="p">{</span>
        <span class="n">Iterator</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="nc">Iterator</span><span class="p">:</span> <span class="n">AsyncIteratorProtocol</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">counter</span> <span class="p">=</span> <span class="mi">0</span>

        <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="k">async</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span>
            <span class="k">guard</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
            <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">1_000_000_000</span><span class="p">)</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">counter</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kd">let</span> <span class="nv">asyncCounterSequence</span> <span class="p">=</span> <span class="n">AsyncCounterSequence</span><span class="p">()</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">counter</span> <span class="k">in</span> <span class="n">asyncCounterSequence</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Task1, counter = </span><span class="si">\(</span><span class="n">counter</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">counter</span> <span class="k">in</span> <span class="n">asyncCounterSequence</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Task2, counter = </span><span class="si">\(</span><span class="n">counter</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// Task2, counter = 1</span>
<span class="c1">// Task1, counter = 1</span>
<span class="c1">// Task1, counter = 2</span>
<span class="c1">// Task2, counter = 2</span>
<span class="c1">// Task1, counter = 3</span>
<span class="c1">// Task2, counter = 3</span>
</div></code></pre><p>As expected, each client has its own independant version of the counter. Under the hood, the <strong>for ... in</strong> loop calls the <strong>makeAsyncIterator()</strong> function and two different <strong>Iterators</strong> are produced, each one having its own <strong>counter</strong> state.</p><p>Just for fun, what would happen if we wanted to share the same iterator in a concurrent context? First we have to make it a reference type so that it is not copied when accessing it from two different Tasks.</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">Iterator</span><span class="p">:</span> <span class="n">AsyncIteratorProtocol</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">counter</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="k">async</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span> <span class="c1">// removing mutating since this is a class</span>
        <span class="k">guard</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">nanoseconds</span><span class="p">:</span> <span class="mi">1_000_000_000</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">counter</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Then we have to use a <strong>while</strong> loop on the same iterator:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">asyncCounterSequence</span> <span class="p">=</span> <span class="n">AsyncCounterSequence</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">iterator</span> <span class="p">=</span> <span class="n">asyncCounterSequence</span><span class="p">.</span><span class="n">makeAsyncIterator</span><span class="p">()</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">while</span> <span class="kd">let</span> <span class="nv">counter</span> <span class="p">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Task1, counter = </span><span class="si">\(</span><span class="n">counter</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">while</span> <span class="kd">let</span> <span class="nv">counter</span> <span class="p">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Task2, counter = </span><span class="si">\(</span><span class="n">counter</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// will print:</span>
<span class="c1">// Task2, counter = 2</span>
<span class="c1">// Task1, counter = 1</span>
<span class="c1">// Task1, counter = 4</span>
<span class="c1">// Task2, counter = 3</span>
<span class="c1">// Task2, counter = 6</span>
<span class="c1">// Task1, counter = 5</span>
</div></code></pre><p>As you can see, the result in non-deterministic since the <strong>next()</strong> function is called concurrently. Some calls will be done by the first Task and some by the second.</p><p>In this dummy usecase it might not be an issue, <strong>BUT</strong> what if an <strong>AsyncSequence</strong> should really be shared with its results being exactly the same for every client?</p><p>A perfect example would be an <strong>AsyncSequence</strong> performing API calls while concurrent clients would process the results in different ways.</p><p>The following <strong>AsyncFetchUsersPagesSequence</strong> fetches pages of <strong>[User]</strong> against a fake Rest API on each call to <strong>next()</strong>:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">AsyncFetchUsersPagesSequence</span><span class="p">:</span> <span class="n">AsyncSequence</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">AsyncIterator</span> <span class="p">=</span> <span class="n">Iterator</span>
    <span class="kd">typealias</span> <span class="n">Element</span> <span class="p">=</span> <span class="p">[</span><span class="n">User</span><span class="p">]</span>

    <span class="kd">func</span> <span class="nf">makeAsyncIterator</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">AsyncIterator</span> <span class="p">{</span>
        <span class="n">Iterator</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="nc">Iterator</span><span class="p">:</span> <span class="n">AsyncIteratorProtocol</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">page</span> <span class="p">=</span> <span class="mi">1</span>

        <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="k">async</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span>
            <span class="k">guard</span> <span class="o">!</span><span class="n">Task</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
            <span class="k">guard</span> <span class="kc">self</span><span class="p">.</span><span class="n">page</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

            <span class="kd">let</span> <span class="nv">request</span> <span class="p">=</span> <span class="n">URLRequest</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="n">URL</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="s">&quot;https://www.server.com/api/users?page=</span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">page</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
            <span class="kd">let</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">_</span><span class="p">)</span> <span class="p">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">URLSession</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">request</span><span class="p">)</span> <span class="c1">// no HTTP status code or error check for the sake of simplicity</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">page</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="k">try</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">([</span><span class="n">User</span><span class="p">].</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Let's take the hypothetical case where we want to concurrently perform two distinct operations on the results, like logging them to the filesystem and persisting them to a database.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">usersPagesSequence</span> <span class="p">=</span> <span class="n">AsyncFetchUsersPagesSequence</span><span class="p">()</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">users</span> <span class="k">in</span> <span class="n">usersPagesSequence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">users</span> <span class="k">in</span> <span class="n">usersPagesSequence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">persist</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>By naively iterating on the sequence like that, we will double the calls to the API (just like with the <strong>Counter</strong> example). Not great performance wise.</p><p>On the other hand, if we share the <strong>AsyncIterator</strong> thanks to a reference type, we will end up having a non-deterministic behavior where some pages are logged and some are persisted. Not great for ... well ... not great!</p><p>In the <strong>Combine</strong> world, we can use a <strong>multicast()</strong> operator to mitigate that kind of issue. This operator ensures the upstream <strong>Publisher</strong> is executed only once while using a <strong>Subject</strong> to distribute the same results to every <strong>Subscribers</strong>.</p><p><a href="https://github.com/AsyncCommunity/AsyncExtensions">AsyncExtensions</a> provides such an <a href="https://github.com/AsyncCommunity/AsyncExtensions/blob/main/Sources/Operators/AsyncSequence%2BMulticast.swift">operator</a>. For it to work well, I had to develop some form of regulation preventing concurrent access to a shared <strong>AsyncSequence</strong> using <strong>Actor</strong>. You can find the details of the regulation mechanism <a href="https://github.com/AsyncCommunity/AsyncExtensions/blob/main/Sources/Internal/ConcurrentAccessRegulator.swift">here</a>.</p><p>With that in place, we can use the <strong>AsyncFetchUsersPagesSequence</strong> without worrying about duplicate calls or non deterministic behavior.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">passthrough</span> <span class="p">=</span> <span class="n">AsyncStreams</span><span class="p">.</span><span class="n">Passthrough</span><span class="o">&lt;</span><span class="p">[</span><span class="n">User</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">multicastedUsersPagesSequence</span> <span class="p">=</span> <span class="n">AsyncFetchUsersPagesSequence</span><span class="p">()</span>
    <span class="p">.</span><span class="n">multicast</span><span class="p">(</span><span class="n">passthrough</span><span class="p">)</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">users</span> <span class="k">in</span> <span class="n">multicastedUsersPagesSequence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Task</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">users</span> <span class="k">in</span> <span class="n">multicastedUsersPagesSequence</span> <span class="p">{</span>
        <span class="k">try</span> <span class="k">await</span> <span class="n">persist</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">multicastedUsersPagesSequence</span><span class="p">.</span><span class="n">connect</span><span class="p">()</span> <span class="c1">// will unlock the client iterations</span>
</div></code></pre><p>API calls will be performed once, while logging and persisting will happen concurrently on the same consecutive results.</p><h1>Conclusion</h1><p><strong>AsyncSequence</strong> is easy to approach due to its simple protocol requirements. When combined with <strong>AsyncStream</strong>, it is definitely a possible replacement for <strong>Combine</strong> in certain situations. Let's just not forget about its <strong>pull</strong> nature and its limitations when it comes to concurrency. <a href="https://github.com/AsyncCommunity/AsyncExtensions">AsyncExtensions</a> aims to ease the usage of structured concurrency in most cases so we don't have to switch between <strong>Combine</strong> and <strong>AsyncSequence</strong>. Some custom operators might have various possible implementations and I tried to respect the <strong>pull</strong> system whenever it was possible. Comments and pull requests are of course welcome so we can challenge those implementations.</p><p>I hope you enjoyed reading. Stay tuned.</p><p>A special thanks to <strong>Ryan F.</strong> for the nice review.</p></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="/Images/avatar.png" alt="Thibault Wittemberg"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Thibault Wittemberg</p><p class="text-gray-600 text-xs md:text-base">Mobile Solution Architect in France üá´üá∑ (thibault.wittemberg@gmail.com)</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2017-12-22-RxFlow-Part3" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2017-12-22-RxFlow-Part3/RxFlow_Logo.png" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">OPEN SOURCE, REACTIVE PROGRAMMING</p><div class="w-full font-bold text-2xl text-gray-900 px-6">RxFlow Part 3: Tips and tricks</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">This is the final chapter of our journey within RxFlow. I‚Äôve already exposed all the key features/principles of the framework in these 2 previous parts, let‚Äôs dive into some tips and tricks I used thanks to Reactive Programming.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">8 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2018-03-24-ElegantlyChainingUiviewpropertyAnimators" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2018-03-24-ElegantlyChainingUiviewpropertyAnimators/Animator_blog.png" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">UIKIT, REACTIVE PROGRAMMING</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Elegantly chaining UIViewPropertyAnimators</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Usually my posts are mostly about design patterns, software architectures (or RxFlow üòÄ), but this time it will be different and frankly I didn't think I would write about this kind of topic. But I think I have something cool to share: so today we are going to talk about Animations with Swift.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">6 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2019-07-20-Swift-AOP" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2019-07-20-Swift-AOP/puzzle.jpg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LANGUAGE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Swift: An Aspect Oriented Programming Language ?</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">To answer this question, we must first understand what is Aspect Oriented Programming (aka AOP). I like to see AOP as a response to a certain kind of failure of Object Oriented conceptions.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">13 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Warp your mobile development</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>