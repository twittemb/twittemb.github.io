<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Warp your mobile development"/><link rel="canonical" href="http://blog.warpfactor.io/posts/2018-01-02-ProtocolOrientedTipsMvvm"/><meta name="twitter:url" content="http://blog.warpfactor.io/posts/2018-01-02-ProtocolOrientedTipsMvvm"/><meta name="og:url" content="http://blog.warpfactor.io/posts/2018-01-02-ProtocolOrientedTipsMvvm"/><title>Protocol Oriented Tips For MVVM in Swift | Warp your mobile development</title><meta name="twitter:title" content="Protocol Oriented Tips For MVVM in Swift | Warp your mobile development"/><meta name="og:title" content="Protocol Oriented Tips For MVVM in Swift | Warp your mobile development"/><meta name="description" content="Hi folks. Lately MVVM has become some sort of standard as an architecture for iOS apps. It offers a good separation of concerns, a good way to format data and great view binding mechanisms with frameworks such as RxSwift. In this post I will give few tips I use to ease the implementation of this pattern."/><meta name="twitter:description" content="Hi folks. Lately MVVM has become some sort of standard as an architecture for iOS apps. It offers a good separation of concerns, a good way to format data and great view binding mechanisms with frameworks such as RxSwift. In this post I will give few tips I use to ease the implementation of this pattern."/><meta name="og:description" content="Hi folks. Lately MVVM has become some sort of standard as an architecture for iOS apps. It offers a good separation of concerns, a good way to format data and great view binding mechanisms with frameworks such as RxSwift. In this post I will give few tips I use to ease the implementation of this pattern."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Warp your mobile development"/></head><head>                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109460106-1"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());

                  gtag('config', 'UA-109460106-1');
                </script></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üçé</span><span class="hidden md:block w-0 md:w-auto pl-1">Warp your mobile development</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/projects">PROJECTS</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/posts">MY POSTS</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">02 JANUARY 2018<span class="text-gray-900 px-1">/</span><a href="/tags/tips">TIPS</a>, <a href="/tags/architecture">ARCHITECTURE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Protocol Oriented Tips For MVVM in Swift</h1></div><div class="container w-full max-w-6xl h-48 md:h-cover mx-auto bg-white bg-cover bg-center mt-8 sm:rounded" style="background-color: #465059; background-image:url('/Images/2018-01-02-ProtocolOrientedTipsMvvm/POP-MVVM.png');"></div><div class="container max-w-5xl mx-auto md:-mt-32"><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><p>Hi folks. Lately MVVM has become some sort of standard as an architecture for iOS apps. It offers a good separation of concerns, a good way to format data and great view binding mechanisms with frameworks such as RxSwift. In this post I will give few tips I use to ease the implementation of this pattern.</p><h1>Views made easy with Reusable</h1><p>With MVVM, separation between Views and the rest of your architecture is very clear. Views include UIViewControllers and their outlets. As a matter of fact, instantiating Views becomes more and more important, especially since patterns such as Coordinator gain in popularity. We will assume in the rest of this article that you are implementing this kind of architecture.</p><p>Reusable is an API that comes with handy extensions to UIViews and UIViewControllers that ease their instantiation in a type safe manner.</p><p>Here is the GitHub repo: <a href="https://github.com/AliSoftware/Reusable">Reusable</a>. It is a lightweight API compatible with Carthage, CocoaPods and SPM. It would be a shame not to use it regarding the happiness it brings üññ.</p><p>Basically, Reusable provides mixins (Protocols with default implementation) that will add instantiation functions to UIViews and UIViewControllers, as soon as you make them conform to the appropriate protocol.</p><p>While using Coordinator pattern, at some point you will want to instantiate UIViewControllers and pass them ViewModels. Lucky you, because Reusable helps a lot in doing that.</p><p>Here are the things you have to do to use Reusable for UIViewControllers instantiation:</p><ul><li>Create a Storyboard file per UIViewController (of course it is possible to have several UIViewControllers in the same storyboard, but for the sake of the simplicity we will consider only one UIViewController)</li><li>Set the UIViewController as the initial ViewController in the scene</li><li>Create a UIViewController file in which the ViewController class name is the same as the Storyboard file name. For instance if the Storyboard file is named ‚ÄúSettingsViewController.storyboard‚Äù, then the UIViewController class will be named ‚ÄúSettingsViewController‚Äù</li><li>Make the UIViewController implement the Protocol ‚ÄúStoryboardBased‚Äù</li></ul><p>And that‚Äôs it. You can now instantiate the ViewController with a single line of code:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">settingsViewController</span> <span class="p">=</span> <span class="n">SettingsViewController</span><span class="p">.</span><span class="n">instantiate</span><span class="p">()</span>
</div></code></pre><p>What is cool about that is that settingsViewController‚Äôs type is SettingsViewController without the need for a cast statement.</p><p>In fact the StoryboardBased protocol is pretty straight forward. Let‚Äôs dive into it:</p><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">protocol</span> <span class="nc">StoryboardBased</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">var</span> <span class="nv">storyboard</span><span class="p">:</span> <span class="bp">UIStoryboard</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">extension</span> <span class="nc">StoryboardBased</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">var</span> <span class="nv">storyboard</span><span class="p">:</span> <span class="bp">UIStoryboard</span> <span class="p">{</span>
    <span class="k">return</span> <span class="bp">UIStoryboard</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">(</span><span class="n">describing</span><span class="p">:</span> <span class="kc">self</span><span class="p">),</span> <span class="n">bundle</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="kc">self</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">extension</span> <span class="nc">StoryboardBased</span> <span class="k">where</span> <span class="kc">Self</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="kc">Self</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">vc</span> <span class="p">=</span> <span class="n">storyboard</span><span class="p">.</span><span class="n">instantiateInitialViewController</span><span class="p">()</span> <span class="k">as</span><span class="p">?</span> <span class="kc">Self</span> <span class="k">else</span> <span class="p">{</span>
      <span class="bp">fatalError</span><span class="p">(</span><span class="s">&quot;The VC of </span><span class="se">\\</span><span class="s">(sceneStoryboard) is not of class </span><span class="se">\\</span><span class="s">(self)&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">vc</span>
  <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Basically, what it does is providing a static ‚Äúinstantiate‚Äù function to each UIViewController that implements the Protocol. This function returns an instance of the UIViewController. As ‚ÄúSelf‚Äù is the return type of the function, type inference assures we won‚Äôt have to cast the result.</p><p>I strongly encourage you to take a deep look at Reusable. It will be also helpful when it comes to instantiate UIViews from Xib or dequeue UITableViewCells in a type safe way.</p><h1>Protocol oriented ViewModels</h1><p>Coordinator-like architectures are common in nowadays applications, especially when being combined to a MVVM pattern. That is why I wished to talk about Reusable in the first place.</p><p>But there is a trick that I find very useful and complementary to Reusable. It fits very well with the MVVM pattern in a Protocol Oriented approach.</p><p>The idea is not only to ease the instantiation of UIViewControllers but also to provide a nice way to pass them their associated ViewModels. Let‚Äôs write a Protocol that defines what it is to have a ViewModel.</p><pre><code><div class="highlight"><span></span><span class="kd">protocol</span> <span class="nc">ViewModelBased</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">ViewModel</span>
    <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModel</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We can now mix it with StoryboardBased and provide a static function that instantiates a UIViewController with a ViewModel as a parameter.</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">ViewModelBased</span> <span class="k">where</span> <span class="kc">Self</span><span class="p">:</span> <span class="n">StoryboardBased</span> <span class="o">&amp;</span> <span class="bp">UIViewController</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span> <span class="p">(</span><span class="n">with</span> <span class="n">viewModel</span><span class="p">:</span> <span class="n">ViewModel</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="kc">Self</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">viewController</span> <span class="p">=</span> <span class="kc">Self</span><span class="p">.</span><span class="n">instantiate</span><span class="p">()</span>
        <span class="n">viewController</span><span class="p">.</span><span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span>
        <span class="k">return</span> <span class="n">viewController</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Conditional extension is a very powerful tool. The ‚Äúwhere‚Äù statement that combines ‚ÄúStoryboardBased‚Äù and ‚ÄúUIViewController‚Äù makes the Self.instantiate function available, so we just have to wrap this call in another static function that sets the UIViewController.viewModel property</p><p>Let‚Äôs say we have a MyViewController that conforms to the ViewModelBased protocol:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">MyViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">StoryboardBased</span><span class="p">,</span> <span class="n">ViewModelBased</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">MyViewModel</span><span class="p">!</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Its instantiation with the ViewModel will be super easy:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">myViewController</span> <span class="p">=</span> <span class="n">MyViewController</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">MyViewModel</span><span class="p">())</span>
</div></code></pre><h1>Let‚Äôs go further in ViewModel abstraction</h1><p>In what we‚Äôve done so far, we still have to instantiate the ViewModel and give it to the View. Wouldn‚Äôt it be nice to just instantiate the View and let it deal with the ViewModel instantiation in a generic way ? Swift type inference can help a lot in doing so.</p><p>Before we dive into the code, I‚Äôd like to warn you that some may say this technic introduce a strong coupling between the View and the ViewModel. In a way this is true, but depending on the amount of time, energy, complexity allocated to your app, it can be an efficient strategy anyway.</p><p>First of all we will define WHAT is a ViewModel. Of course we will use a Protocol for that. And by doing so, we‚Äôll introduce the notion of Services. Services are low level layers that are needed by the ViewModel to retrieve data or perform actions.</p><pre><code><div class="highlight"><span></span><span class="kd">protocol</span> <span class="nc">ViewModel</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">Services</span>
    <span class="kd">init</span> <span class="p">(</span><span class="n">withServices</span> <span class="n">services</span><span class="p">:</span> <span class="n">Services</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>We have to amend the ViewModelBased definition to introduce the ViewModel protocol in the associated type.</p><pre><code><div class="highlight"><span></span><span class="kd">protocol</span> <span class="nc">ViewModelBased</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">ViewModelType</span><span class="p">:</span> <span class="n">ViewModel</span>
    <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModelType</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Finally we can adapt the ViewModelBased extension like this:</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">ViewModelBased</span> <span class="k">where</span> <span class="kc">Self</span><span class="p">:</span> <span class="n">StoryboardBased</span> <span class="o">&amp;</span> <span class="bp">UIViewController</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span><span class="p">&lt;</span><span class="n">ServicesT</span><span class="p">&gt;</span> <span class="p">(</span><span class="n">withServices</span> <span class="n">services</span><span class="p">:</span> <span class="n">ServicesT</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="kc">Self</span>
    <span class="k">where</span> <span class="n">ServicesT</span> <span class="p">==</span> <span class="kc">Self</span><span class="p">.</span><span class="n">ViewModelType</span><span class="p">.</span><span class="n">Services</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">viewController</span> <span class="p">=</span> <span class="kc">Self</span><span class="p">.</span><span class="n">instantiate</span><span class="p">()</span>
        <span class="n">viewController</span><span class="p">.</span><span class="n">viewModel</span> <span class="p">=</span> <span class="n">ViewModelType</span><span class="p">(</span><span class="n">withServices</span><span class="p">:</span> <span class="n">services</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">viewController</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>There are 2 main differences between this version and the previous one:</p><ul><li>the first difference is obvious: this static function not only instantiates the UIViewController but also the ViewModel. That‚Äôs one thing the developper won‚Äôt have to do anymore üëç</li><li>the second difference is the function signature. It now takes some kind of Services as a parameter. As you can see, this is a generic function. The ‚Äúwhere‚Äù statement forces the developper to pass a ServicesT that is the same as the one required in the ViewModelType. This brings safety and consistency üëç</li></ul><p>What is great here is that Swift will infer the ViewModelType according to the ViewModelBased implementation.</p><p>Let‚Äôs see this in action.</p><p>First thing first, we have to define a dumb Service for the sake of this demonstration:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">MyService</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">executeService</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;Service execution&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>We can now define a ViewModel that needs this Service:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">MyViewModel</span><span class="p">:</span> <span class="n">ViewModel</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">Services</span> <span class="p">=</span> <span class="n">MyService</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">withServices</span> <span class="n">services</span><span class="p">:</span> <span class="n">Services</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">executeService</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>MyViewController instantiation with its ViewModel becomes that easy (considering that we already have a MyService instance):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">myViewController</span> <span class="p">=</span> <span class="n">MyViewController</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">withServices</span><span class="p">:</span> <span class="n">myService</span><span class="p">)</span>
<span class="c1">// we can access the inner ViewModel if needed: myViewController.viewModel</span>
</div></code></pre><h1>Protocol composition for Services</h1><p>Although this seems pretty handy, there is one drawback to this pattern: what if a ViewModel needs several Services ?</p><p>One solution would be to pass some kind of container that provides ALL the services of your application. This would work, but not very safe because the ViewModel could use every services of the container without restriction.</p><p>I once read a <a href="http://merowing.info/2017/04/using-protocol-compositon-for-dependency-injection/">post from Krzysztof Zablocki</a> about this issue and I though it would work very gently with my ViewModel approach.</p><p>Let‚Äôs say our application needs 3 services:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">Service1</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">executeService1</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;execution of Service1&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Service2</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">executeService2</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;execution of Service2&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Service3</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">executeService3</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;execution of Service3&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>The idea is to use Protocol composition to express the services we need in our ViewModel. We will define a Protocol per Service that grants access to it:</p><pre><code><div class="highlight"><span></span><span class="kd">protocol</span> <span class="nc">HasService1</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">service1</span><span class="p">:</span> <span class="n">Service1</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="nc">HasService2</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">service2</span><span class="p">:</span> <span class="n">Service2</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="nc">HasService3</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">service3</span><span class="p">:</span> <span class="n">Service3</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>In our ViewModels we now have the ability to clearly define our dependancies, with a fine granularity:</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">MyViewModel</span><span class="p">:</span> <span class="n">ViewModel</span> <span class="p">{</span>

    <span class="c1">// thanks to protocol composition we define only the services we want to use</span>
    <span class="kd">typealias</span> <span class="n">Services</span> <span class="p">=</span> <span class="n">HasService1</span> <span class="o">&amp;</span> <span class="n">HasService2</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">withServices</span> <span class="n">services</span><span class="p">:</span> <span class="n">Services</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">service1</span><span class="p">.</span><span class="n">executeService1</span><span class="p">()</span>
        <span class="n">services</span><span class="p">.</span><span class="n">service2</span><span class="p">.</span><span class="n">executeService2</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">MyOtherViewModel</span><span class="p">:</span> <span class="n">ViewModel</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="n">Services</span> <span class="p">=</span> <span class="n">HasService2</span> <span class="o">&amp;</span> <span class="n">HasService3</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">withServices</span> <span class="n">services</span><span class="p">:</span> <span class="n">Services</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">services</span><span class="p">.</span><span class="n">service2</span><span class="p">.</span><span class="n">executeService2</span><span class="p">()</span>
        <span class="n">services</span><span class="p">.</span><span class="n">service3</span><span class="p">.</span><span class="n">executeService3</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>The last step is to define the dependancy container:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">MyServices</span><span class="p">:</span> <span class="n">HasService1</span><span class="p">,</span> <span class="n">HasService2</span><span class="p">,</span> <span class="n">HasService3</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">service1</span> <span class="p">=</span> <span class="n">Service1</span><span class="p">()</span>
    <span class="kd">let</span> <span class="nv">service2</span> <span class="p">=</span> <span class="n">Service2</span><span class="p">()</span>
    <span class="kd">let</span> <span class="nv">service3</span> <span class="p">=</span> <span class="n">Service3</span><span class="p">()</span>
<span class="p">}</span>
</div></code></pre><p>And we‚Äôre good to go, we can now pass the container to our ViewModels with a decent safety but a great scalability. If we need to access another Service inside a ViewModel, we just have to update the protocol composition.</p><p>At the end, UIViewController instantiation is the same (consider that MyViewController2 is a ViewModelBased VC):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">myViewController</span> <span class="p">=</span> <span class="n">MyViewController</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">withServices</span><span class="p">:</span> <span class="n">myServices</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">myViewController2</span> <span class="p">=</span> <span class="n">MyViewController2</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">withServices</span><span class="p">:</span> <span class="n">myServices</span><span class="p">)</span>
<span class="c1">// This is the same myServices instance for the 2 ViewControllers</span>
<span class="c1">// but each ViewModel will only access what&#39;s needed</span>
</div></code></pre><p>Et voila üëå.</p><p>I hope this helps.</p><p>Stay tuned.</p></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="/Images/avatar.png" alt="Thibault Wittemberg"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Thibault Wittemberg</p><p class="text-gray-600 text-xs md:text-base">Mobile Solution Architect in France üá´üá∑ (thibault.wittemberg@gmail.com)</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2022-03-13-AsyncSequenceExtensions" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2022-03-13-AsyncSequenceExtensions/header.jpg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">OPEN SOURCE, LANGUAGE, REACTIVE PROGRAMMING, FUNCTIONAL PROGRAMMING</p><div class="w-full font-bold text-2xl text-gray-900 px-6">AsyncSequence extensions</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Swift 5.5 introduced structured concurrency, and with it came AsyncSequence: a new way to provide a flow of values over time. Wait, what? Isn't this what Combine is all about? From Apple: "The Combine framework provides a declarative Swift API for processing values over time". Are these technologies similar? Interchangeable? Well, sort of! In this article we will explore the differences and similarities between them and we will go over a repo that brings Combine-like operators to AsyncSequence.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">13 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2019-06-18-PropertyWrappers" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2019-06-18-PropertyWrappers/wrapper.png" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LANGUAGE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Property Wrappers In Swift 5.1, The Missing Published Implementation</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">It‚Äôs been an amazing WWDC this year. SwiftUI and Combine were some big announcements of the conference. They will have a huge impact on our daily life as iOS developers.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">6 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/2019-07-20-Swift-AOP" class="flex flex-wrap no-underline hover:no-underline"><img src="/Images/2019-07-20-Swift-AOP/puzzle.jpg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LANGUAGE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Swift: An Aspect Oriented Programming Language ?</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">To answer this question, we must first understand what is Aspect Oriented Programming (aka AOP). I like to see AOP as a response to a certain kind of failure of Object Oriented conceptions.</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="/Images/avatar.png" alt="Thibault Wittemberg"/><p class="text-gray-600 text-xs md:text-sm">13 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Warp your mobile development</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>